# 浏览器的同源策略
同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。

同源策略，它是由Netscape提出的一个著名的安全策略。现在所有支持JavaScript 的浏览器都会使用这个策略。所谓同源是指，域名，协议，端口相同。当一个浏览器的两个tab页中分别打开来百度和谷歌的页面当浏览器的百度tab页执行一个脚本的时候会检查这个脚本是属于哪个页面的，即检查是否同源，只有和百度同源的脚本才会被执行。

# 同源策略的重要性
将一个学校内的学生看作不同源的个体。虽然一个班级里面有许多学生，但是他们都是互不相关的个体。学生家长请求老师提供同学们的学习成绩报告，老师会告诉家长，你只能够查看自家孩子的学习成绩报告。同理，学校收到请求要对一个学生的学习成绩进行评价，那么在出具评价报告之前，学校需要对请求者的身份进行确认。这就是与浏览器密切相关的同源策略。继续假设，学校允许任何人不经过身份确认查看学生的学习成绩报告，这就和浏览器没有同源策略一样。

同源策略机制为现代广泛依赖于cookie维护用户会话的Web浏览器定义了一个特殊的功能，严格隔离不相关的网站提供的内容，防止客户端数据机密性或完整性丢失。

# 开发过程中跨域的重要性

# 跨域请求的重要注意点
**跨域请求并非是浏览器限制了发起跨站请求，而是请求可以正常发起，到达服务器端，但是服务器返回的结果会被浏览器拦截。**
# 前端跨域请求的方法

## JSONP的方式
其原理是根据XmlHttpRequest对象受到同源策略的影响，而\<script\>标签元素却不受同源策略影响，可以加载跨域服务器上的脚本，网页可以从其他来源动态产生JSON资料。用JSONP获取的不是JSON数据，而是可以直接运行的JavaScript语句。

**JSONP的方式不受浏览器兼容性的限制**。JSONP本质上是利用\<script\>标签的跨域能力实现跨域数据的访问，请求动态生成的JavaScript脚本同时带一个callback函数名作为参数。其中callback函数本地文档的JavaScript函数，服务器端动态生成的脚本会产生数据，并在代码中以产生的数据为参数调用 callback函数。当这段脚本加载到本地文档时，callback函数就被调用。

### 使用jQuery集成的$.ajax实现JSONP的跨域调用

### 使用script标签原生实现JSONP

### JSONP的总结与不足
JSONP可以帮助我们实现前端的跨域请求。但是，在实践的过程中，我们可以看到它存在以下不足：

* **只能使用GET方式发起请求（与其实现原理有关）**。
* **不能很好的发现错误进行处理。与上述ajax的方式相比，不能注册成功、失败的回调函数**。

## CORS的方式
跨域资源共享，Cross-Origin Resource Sharing是由W3C提出的一个用于浏览器以XMLHttpRequest方式向其他源的服务器发起请求的规范。不同于JSONP，CORS是以Ajax方式进行跨域请求，需要服务端与客户端的同时支持。目前CORS在绝大部分现代浏览器中都是支持的。

Cross-Origin Resource Sharing（CORS）跨域资源共享是一份浏览器技术的规范，提供了 Web 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，是 JSONP 模式的现代版。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。用 CORS 可以让网页设计师用一般的 XMLHttpRequest，这种方式的错误处理比 JSONP 要来的好。另一方面，JSONP 可以在不支持 CORS 的老旧浏览器上运作。现代的浏览器都支持 CORS。

## window.name的跨域方式
window对象有个name属性，该属性有个特征：即在一个窗口 (window) 的生命周期内，窗口载入的所有的页面都是共享一个 window.name 的，每个页面对 window.name 都有读写的权限，window.name 是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。

window 对象的name属性是一个很特别的属性，当该window的location变化，然后重新加载，它的name属性可以依然保持不变。那么我们可以在页面 A中用iframe加载其他域的页面B，而页面B中用JavaScript把需要传递的数据赋值给window.name，iframe加载完成之后，页 面A修改iframe的地址，将其变成同域的一个地址，然后就可以读出window.name的值了。这个方式非常适合单向的数据请求，而且协议简单、安 全。不会像JSONP那样不做限制地执行外部脚本。

## window.postMessage()的方式
这个方法是 HTML5 的一个新特性，可以用来向其他所有的 window 对象发送消息。需要注意的是我们必须要保证所有的脚本执行完才发送 MessageEvent，如果在函数执行的过程中调用了他，就会让后面的函数超时无法执行。[有关postMessage](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage)

## document.domain的方式
通过修改document的domain属性，我们可以在域和子域或者不同的子域之间通信。同域策略认为域和子域隶属于不同的域，比如www.a.com 和 sub.a.com是不同的域，这时，我们无法在www.a.com下的页面中调用sub.a.com中定义的JavaScript方法。但是当我们把它 们document的domain属性都修改为a.com，浏览器就会认为它们处于同一个域下，那么我们就可以互相调用对方的method来通信了。

# Fetch
JavaScript 通过XMLHttpRequest(XHR)来执行异步请求，这个方式已经存在了很长一段时间。虽说它很有用，但它不是最佳API。它在设计上不符合职责分离原则，将输入、输出和用事件来跟踪的状态混杂在一个对象里。而且，基于事件的模型与最近JavaScript流行的Promise以及基于生成器的异步编程模型不太搭。新的 Fetch API打算修正上面提到的那些缺陷。 它向JS中引入和HTTP协议中同样的原语。具体而言，它引入一个实用的函数 fetch() 用来简洁捕捉从网络上检索一个资源的意图。Fetch 规范 的API明确了用户代理获取资源的语义。它结合ServiceWorkers，尝试达到以下优化：

* 改善离线体验
* 保持可扩展性

而与jQuery相比， fetch 方法与 jQuery.ajax() 的主要区别在于：

* fetch()方法返回的Promise对象并不会在HTTP状态码为404或者500的时候自动抛出异常，而需要用户进行手动处理
* 默认情况下，fetch并不会发送任何的本地的cookie到服务端，注意，如果服务端依靠Session进行用户控制的话要默认开启Cookie

## 基于Fetch的CORS代码封装
